[{"content":"Intro Sempre me interessei pelo mercado financeiro e por toda a tecnologia que esse mercado já usa de ferramenta, como por exemplo HFT\u0026rsquo;s (High-Frequency Trading) e Quantitative Trading, temas que unem o melhor do mercado de tecnologia e financeiro.\nPesquisando sobre o tema vi que grandes bancos já usam essas e outras tecnologias para ajudar na tomada de decisão ou para recomendar investimentos para os seus clientes, e pensando em uma escala menor decidi criar um advisor que pudesse me ajudar a analisar todas as ações da bolsa brasileira de forma massiva e me mostrasse apenas aquelas ações que estivessem com algum sinal \u0026ldquo;interessante\u0026rdquo; com base em alguns parâmetros.\n Bom, mas como e onde conseguir os dados para fazer essas análises?\n Navegando bastante entre um post e outro encontrei o post do Ran Aroussi criador dessa lib fantástica escrita em python, era exatamente o que eu precisava para começar o meu projeto de bot que iria fazer todo o trabalho chato no meu lugar.\nComo instalar e usar a lib yfinance Para usar a lib yfinance voce vai precisar ter o python \u0026gt;=3.4 e o pip instalado, veja aqui como instalar no Windows, Linux e MacBook\nCom o python e pip instalados, execute o comando à seguir no terminal:\npip install yfinance --upgrade --no-cache-dir Pronto, agora voce já consegue comecar a usar.\nFazendo o download de dados históricos uma ação por vez Primeiro crie um arquivo com a extensão *.py e adicione as seguintes linhas:\nimport yfinance as yf ticker = \u0026#34;VALE3.SA\u0026#34; period = \u0026#34;1y\u0026#34; interval = \u0026#34;1wk\u0026#34; historical_data = yf.Ticker(ticker).history(period, interval, actions=False).dropna() print(historical_data) \u0026#34;\u0026#34;\u0026#34; Open High Low Close Volume Date 2019-12-29 51.497285 52.313177 51.065340 51.766048 46722600.0 2020-01-05 51.641265 52.188394 50.921359 51.218922 88179900.0 2020-01-12 51.487684 54.799253 51.362899 54.712864 126412900.0 2020-01-19 54.712866 55.058422 51.535679 51.641266 102226200.0 2020-01-26 49.587132 49.999879 47.801764 48.252907 138220500.0 \u0026#34;\u0026#34;\u0026#34;  Vou fazer uma série de posts, mostrando as soluções que estou usando na construção desse \u0026ldquo;advisor\u0026rdquo;, irei organizar todos os posts dessa série na tag Financial Advisor Bot.\n Click aqui para ir para o próximo post.\n No final iremos gerar um relatório igual à esse:\n ","permalink":"https://fmaced1.github.io/post/dados-historicos-acoes-b3/","summary":"Intro Sempre me interessei pelo mercado financeiro e por toda a tecnologia que esse mercado já usa de ferramenta, como por exemplo HFT\u0026rsquo;s (High-Frequency Trading) e Quantitative Trading, temas que unem o melhor do mercado de tecnologia e financeiro.\nPesquisando sobre o tema vi que grandes bancos já usam essas e outras tecnologias para ajudar na tomada de decisão ou para recomendar investimentos para os seus clientes, e pensando em uma escala menor decidi criar um advisor que pudesse me ajudar a analisar todas as ações da bolsa brasileira de forma massiva e me mostrasse apenas aquelas ações que estivessem com algum sinal \u0026ldquo;interessante\u0026rdquo; com base em alguns parâmetros.","title":"Fazendo o download dos dados históricos de ações usando o yfinance"},{"content":"Intro O Canary Release é uma estratégia de deploy que consiste em rotear uma parte dos seus usuários para uma nova versão, com isso você consegue monitorar qual será o comportamento dessa nova versão sem afetar a todos os seus usuários caso ocorra algum erro.\nHá algumas maneiras de fazer isso, no Kubernetes isso é possível nativamente aumentando o número de réplicas dos pods novos e diminuindo os pods com a versão antiga, porém para ter uma porcentagem de 1% da nova versão, nós teríamos que ter necessariamente 1 pod com a versão nova e outros 99 com a versão antiga, o que não vai de encontro com a filosofia do Docker/Kubernetes que vieram para resolver a otimização de recursos entre outros problemas.\nOutra forma de implementar essa estratégia é usando um Load Balancer nesse caso vamos usar o Nginx, com ele conseguimos manipular encaminhamento das requisições dizendo que uma porcentagem do tráfego irá para uma versão especifica, com isso podemos ter somente 1 pod com a nova versão e 1 com a antiga e ainda assim atender 1% das transações com a nova versão.\nInstalação no cluster Kubernetes Primeiro faça o clone do projeto https://github.com/fmaced1/canary-release-nginx-ingress-controller\ngit clone https://github.com/fmaced1/canary-release-nginx-ingress-controller Para essa demo, iremos usar o namespace canary, mude nos arquivos yaml para o namespace que preferir.\nInstale o nginx ingress controller:\nkubectl apply -f nginx-ingress-controller/ingress-nginx-manifests.yaml -f nginx-ingress-controller/expose-ingress-nginx.yaml kubectl rollout status deploy nginx-ingress-controller -n ingress-nginx -w Se você estiver em um cluster Kubernetes que não tenha um Load Balancer, instale o MetalLB ele irá atribuir um ip público ao seu Nginx (Ingress Controller), se você estiver em um ambiente cloud provavelmente você já tem um LB do seu provider.\nAjuste o range de ips que serão alocados para o MetalLB gerenciar:\n# metallb/configmap-metallb.yaml apiVersion: v1 kind: ConfigMap metadata: namespace: metallb-system name: config data: config: | address-pools: - name: default protocol: layer2 addresses: - 192.168.x.y-192.168.x.z # ajuste aqui o range de ips Instale o MetalLB para ter um loadbalancer:\nkubectl apply -f metallb/configmap-metallb.yaml kubectl apply -f metallb/metallb-manifests.yaml Canary release Faça o deploy da aplicação v1:\n# app-v1.yaml contém o deploy e o svc # ingress-v1.yaml contém a rota kubectl apply -f nginx-canary/apps/app-v1.yaml -f nginx-canary/apps/ingress-v1.yaml Agora faça o deploy da segunda versão:\n# app-v2.yaml contém o deploy e o svc kubectl apply -f nginx-canary/apps/app-v2.yaml Liste o serviço ingress-nginx para saber o ip que a sua app irá responder, esse ip irá responder por k8s.local.\nkubectl get svc ingress-nginx -n ingress-nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ingress-nginx LoadBalancer 10.106.17.108 192.168.x.y 80:31574/TCP 53m Como não temos um dns, vamos colocar o nome da maquina no /etc/hosts apontando para um nome qualquer:\nexport EXTERNAL_IP_INGRESS_NGINX=\u0026#34;192.168.x.y\u0026#34; echo \u0026#34;$EXTERNAL_IP_INGRESS_NGINXk8s.local\u0026#34; \u0026gt;\u0026gt; /etc/hosts Depois disso conseguimos fazer uma requisição para a rota da aplicação, deixe esse comando rodando em outro terminal:\ncount=0; while sleep 0.3; do let count+=1 ;echo $count - $(curl -s k8s.local); done # output 1 - Host: my-app-v1-84ff7f48cc-kcn57, Version: v1.0.0 2 - Host: my-app-v1-84ff7f48cc-kcn57, Version: v1.0.0 3 - Host: my-app-v1-84ff7f48cc-kcn57, Version: v1.0.0 Agora vamos dividir o tráfego, 10% para o svc app-v2 e o resto continua no svc da app-v1:\nkubectl apply -f nginx-canary/by-weight/ingress-v2-canary.yaml Veja que de 300 requisições apenas 32 foram para app v2: bash canary/nginx-canary/curl-canary.sh k8s.local ... v1: 290 v2: 30 - Host: my-app-v1-84ff7f48cc-4d9kq, Version: v1.0.0 v1: 291 v2: 30 - Host: my-app-v1-84ff7f48cc-4d9kq, Version: v1.0.0 v1: 292 v2: 30 - Host: my-app-v1-84ff7f48cc-4d9kq, Version: v1.0.0 v1: 293 v2: 30 - Host: my-app-v1-84ff7f48cc-4d9kq, Version: v1.0.0 v1: 294 v2: 30 - Host: my-app-v1-84ff7f48cc-4d9kq, Version: v1.0.0 v1: 295 v2: 30 - Host: my-app-v1-84ff7f48cc-4d9kq, Version: v1.0.0 v1: 296 v2: 30 - Host: my-app-v1-84ff7f48cc-4d9kq, Version: v1.0.0 v1: 297 v2: 30 - Host: my-app-v1-84ff7f48cc-4d9kq, Version: v1.0.0 v1: 297 v2: 31 - Host: my-app-v2-dfdff8845-n6bml, Version: v2.0.0 v1: 298 v2: 31 - Host: my-app-v1-84ff7f48cc-4d9kq, Version: v1.0.0 v1: 299 v2: 31 - Host: my-app-v1-84ff7f48cc-4d9kq, Version: v1.0.0 v1: 300 v2: 31 - Host: my-app-v1-84ff7f48cc-4d9kq, Version: v1.0.0 v1: 300 v2: 32 - Host: my-app-v2-dfdff8845-n6bml, Version: v2.0.0 Quando estiver satisfeito com a app-v2, exclua o ingress-canary:\nkubectl delete -f nginx-canary/by-weight/ingress-v2-canary.yaml E vire todo o tráfego para a app-v2\nkubectl apply -f nginx-canary/apps/ingress-v2.yaml ","permalink":"https://fmaced1.github.io/post/como-fazer-cache-de-objetos-com-python/","summary":"Intro O Canary Release é uma estratégia de deploy que consiste em rotear uma parte dos seus usuários para uma nova versão, com isso você consegue monitorar qual será o comportamento dessa nova versão sem afetar a todos os seus usuários caso ocorra algum erro.\nHá algumas maneiras de fazer isso, no Kubernetes isso é possível nativamente aumentando o número de réplicas dos pods novos e diminuindo os pods com a versão antiga, porém para ter uma porcentagem de 1% da nova versão, nós teríamos que ter necessariamente 1 pod com a versão nova e outros 99 com a versão antiga, o que não vai de encontro com a filosofia do Docker/Kubernetes que vieram para resolver a otimização de recursos entre outros problemas.","title":"Canary release usando o Nginx Ingress Controller no K8s"},{"content":"Intro Continuando a série \u0026ldquo;Financial Advisor Bot\u0026rdquo; que inicia nesse post aqui.\nNesse post irei compartilhar a solução de cache que estou usando, bem simples e direto ao ponto. O objetivo aqui é mostrar uma solução de cache que é fácil de implementar e que já irá evitar que o seu serviço fique indisponível, e de quebra irá diminuir bastante o seu tempo de resposta.\nPrimeiro, suba uma instância do redis Se você já não tiver uma instância do redis:\nInstale o docker, escolha de acordo com a sua plataforma aqui.\nNesse link você consegue ver as versões disponíveis, crie também, uma conta no docker hub, precisaremos dela para conseguir fazer o download da imagem do redis.\ndocker login docker pull redis # Caso queira outra versão, especifique depois dos : (dois pontos) #docker pull redis:[version] docker network create redis docker run -d --name=redis --network redis -p 6379:6379 redis:latest Usando o redis Ao invés de baixar os dados todas as vezes que precisamos dos dados históricos de uma ação, porque não guardar em cache? Afinal o yahoo atualiza as cotações só depois de 15 minutos, e para a nossa análise o que importa é a cotação semanal.\nPara isso vamos criar um método/função get_data_history, ela irá bater no redis e buscar os dados daquela ação, se o redis não tiver esses dados, vamos fazer o download e guardar no redis, assim nas próximas vezes os dados já estarão em cache, como vamos passar um tempo de expiração o redis vai apagar essa informação depois de 1 hora.\nNome do arquivo deve ser _redis.py, porque iremos importa-lo no próximo arquivo\nimport redis, pickle, zlib, os class RedisCache(object): def __init__(self): redis_host = os.getenv(\u0026#39;REDIS_HOST\u0026#39;) redis_port = os.getenv(\u0026#39;REDIS_PORT\u0026#39;) if redis_host == None and redis_port == None: redis_host = \u0026#34;localhost\u0026#34; redis_port = 6379 self.redis_client = redis.StrictRedis(host=redis_host, port=redis_port) def get_value(self, _key): \u0026#34;\u0026#34;\u0026#34; Get content from redis Args: _key ([string]) Returns: [dict]: [Dataframe] \u0026#34;\u0026#34;\u0026#34; return pickle.loads(zlib.decompress(self.redis_client.get(_key))) def set_value(self, _key, _value, expiration_seconds): \u0026#34;\u0026#34;\u0026#34; Loads data object into redis Args: _key ([string]): [key must be string] _value ([json]): [Loads data to compress with zlib and store into redis] expiration_seconds ([int]): [life time seconds limit for data] \u0026#34;\u0026#34;\u0026#34; self.redis_client.setex(_key, expiration_seconds, zlib.compress(pickle.dumps(_value))) from _redis import RedisCache expiration_seconds = (60*60)*1 #1hr def get_data_history(ticker=str, period=str, interval=str, expiration_seconds=int): try: return RedisCache.get_redis(ticker) except Exception: data = yf.Ticker(ticker).history(period, interval, actions=False).dropna() RedisCache.set_value(ticker, data, expiration_seconds) return RedisCache.get_redis(ticker) ticker = \u0026#34;STBP3.SA\u0026#34; period = \u0026#34;1y\u0026#34; interval = \u0026#34;1wk\u0026#34; # Assim quando chamarmos essa função, ela irá retornar um dataframe com as cotações da ação. print(get_data_history(ticker, period, interval, expiration_seconds)) Como manipular esses dados no redis? Enquanto o container estiver de pé, conseguiremos ver esses dados que que estão em memória no redis.\nPara acessar os dados de uma determinada ação, rode o comando à seguir:\ndocker exec -it redis redis-cli get VALE3.SA E para apagar todos os dados do redis:\ndocker exec -it redis redis-cli FLUSHDB Esse post faz parte da série \u0026ldquo;Financial Advisor Bot\u0026rdquo;, mostrando as soluções que estou usando na construção desse \u0026ldquo;advisor\u0026rdquo;, irei organizar todos os posts dessa série aqui Financial Advisor Bot.\nClick aqui para ir para o próximo post.\n","permalink":"https://fmaced1.github.io/post/como-fazer-cache-de-objetos-com-python-copy/","summary":"Intro Continuando a série \u0026ldquo;Financial Advisor Bot\u0026rdquo; que inicia nesse post aqui.\nNesse post irei compartilhar a solução de cache que estou usando, bem simples e direto ao ponto. O objetivo aqui é mostrar uma solução de cache que é fácil de implementar e que já irá evitar que o seu serviço fique indisponível, e de quebra irá diminuir bastante o seu tempo de resposta.\nPrimeiro, suba uma instância do redis Se você já não tiver uma instância do redis:","title":"Como fazer cache de objetos usando python e redis"},{"content":"Intro Pretendo compartilhar aqui algumas dicas que não estão na maioria dos posts que vi pela internet quando estava me preparando para a prova.\nEsse post não é um guia de estudos para a certificação CKA, mas se você está procurando por um, recomendo esses:\n https://ravikirans.com/cka-kubernetes-exam-study-guide/ https://dev.to/kodekloud/tips-and-tricks-to-pass-the-cka-and-ckad-exam-c76 https://codeburst.io/the-ckad-browser-terminal-10fab2e8122e https://jimangel.io/post/cka-exam-for-experienced-kubernetes-operators/  Links oficiais sobre a cka:  Sobre a certificação [Link] O que cai na prova? [Link]  Principais tópicos e seus respectivos pesos:    Domain Weight     Troubleshooting 30%   Cluster Architecture, Installation \u0026amp; Configuration 25%   Services \u0026amp; Networking 20%   Workloads \u0026amp; Scheduling 15%   Storage 10%    Não comece pelo kubernetes-the-hard-way O tutorial do @kelseyhightower é excelente, porém acho que não é uma boa idéia investir um tempo considerável, executando um passo a passo que você não irá entender muita coisa do que fez, quando terminar.\nDepois de um tempo de estudo, quando já estiver entendendo como funciona os principais componentes, aconselho sim que execute o tutorial pelo menos 2 vezes, tente não entrar em um modo automático, apenas copiando e colando os comandos.\nhttps://github.com/kelseyhightower/kubernetes-the-hard-way\nDocumentação de versões passadas Quando fiz a prova a documentação do Kubernetes estava mudando para a versão 1.20, fui consultar um comando de instalação que estava lá a dois dias atrás\u0026hellip; não estava mais lá rsrs, revirei a documentação, perdi uns 2 min e só depois lembrei que tinha como mudar para a versão anterior.\nTenha uma máquina windows de reserva Quando fiz o exame perdi cerca de 20 minutos antes do inicio da prova, tempo que levei tentando compartilhar a câmera do Macbook pelo Chrome e no final acabar trocando de notebook para um com Windows.\nComo é a tela da prova? Dominando o vim O vim é um editor derivado do vi presente na maioria das distribuições linux e unix, bem complexo, mas muito eficiente, no exame você terá apenas uma aba com um terminal linux no caso um ubuntu.\nDominar o vim vai te ajudar muito a economizar tempo na hora do seu exame, acredite 2 horas não dá pra nada, já que as perguntas são totalmente práticas e um detalhe esquecido pode fazer muita diferença no resultado da questão.\n   Comandos Descrição     i Habilita a inserção de texto onde está o cursor   esc : q ! Sai do vim confirmando que não quer salvar (Mais usado)   esc : w q ! Salva e sai do vim   esc d 99 d Apaga 99 linhas à partir do cursor   esc dd Apaga a linha inteira onde o cursor está   esc : % s/x/y/g Faz o replace de x por y em todas as vezes que x aparece no arquivo   esc gg Move o cursor para a primeira linha do arquivo   esc : set number Habilita a numeração das linhas do arquivo   esc G Move para o final do arquivo   esc /texto_exemplo Procura pela palavra texto_exemplo no arquivo   esc /texto_exemplo + n Pula para a próxima ocorrência   esc /texto_exemplo + N Pula para a ocorrência anterior    Com esses comandos você consegue copiar, colar e apagar blocos de código:\n   Comandos Descrição     esc + V + (seta cima / baixo) Seleciona as linhas que serão copiadas   y copia as linhas selecionadas   d Apaga as linhas selecionadas   p ou P Cola as linhas selecionadas    Como splitar a tela com o TMUX O tmux não vem instalado por padrão no servidor que é usado no exame, para instalar é bem simples basta rodar isso:\nsudo apt -y install tmux # caso não funcione, tente rodar os seguintes comandos e depois rodar o install novamente: # sudo apt update # sudo apt upgrade Principais comandos tmux que podem ser usados no exame:\n# O prefix deverá ser usado antes de todos os comandos ao tmux. {prefix} = ctrl + b ctrl + b + \u0026quot; Divide a janela na horizontal ctrl + b + % Divide a janela na horizontal ctrl + b + {Arrow-Key} Muda de janela ctrl + b + c Cria uma nova janela ctrl + b + p Pula para a janela anterior ctrl + b + n Pula para a proxima janela ctrl + b + {Page-up-Key} Desliza a pagina na janela atual ctrl + b + {Arrow-Key} Aumenta ou diminui o tamanho da janela atual ctrl + d Sai da janela atual Deletar objetos pode te custar alguns segundos Aqui vai uma dica quase niguém fala e que me ajudou bastante, deletar objetos no kubernetes pode demorar alguns segundos principalmente quando tem alguma secret, configmap ou volume atrelada à ela, no caso de deployment ou pod.\nkubectl -f delete objeto.yaml ; ctrl+z + bg O comando ctrl+z + bg coloca o comando anterior em backgroud e te libera a linha de comando para ir editando o yml e isso economiza aqueles segundos que fazem a diferença.\nSe quiser voltar o comando para foreground, só digitar:\nfg Kubectl aliases e autocompletion Sem dúvida os aliases mais importantes são o k=\u0026quot;kubectl\u0026quot; e o $dry, não usei muitos aliases como nesse projeto, porque sinceramente não achei que valesse muito a pena, afinal iria acabar perdendo mais tempo tentando lembrar dos comandos do que realmente fazendo o que precisava.\nexport dry=\u0026#34;--dry-run=client -o yaml\u0026#34; # Cria um yaml com o manifest de um pod nginx kubectl run nginx --image nginx $dry \u0026gt; nginx_pod.yaml # Mesmo que o anterior, porém aqui cria um deployment ao invés de um pod kubectl create deploy nginx --image nginx $dry \u0026gt; deploy.yaml E para habilitar o autocomplete do kubectl, aqui está o link da documentação oficial\necho \u0026#39;source \u0026lt;(kubectl completion bash)\u0026#39; \u0026gt;\u0026gt;~/.bashrc echo \u0026#39;alias k=kubectl\u0026#39; \u0026gt;\u0026gt;~/.bashrc echo \u0026#39;complete -F __start_kubectl k\u0026#39; \u0026gt;\u0026gt;~/.bashrc Anote as respostas Logo que iniciar o exame, rode esse comando à seguir no terminal:\nfor i in $(seq 1 24);do echo \u0026#34;$i- \u0026#34; ;done Isso irá gerar 24 linhas no seguinte formato:\n1 - 2 - 3 - 4 - ... 24 - Depois copie e cole no notepad da plataforma, assim você conseguirá marcar as questões feitas e o peso.\nNo final o meu notepad do exame ficou algo parecido com isso:\nQuestões, Peso, OK/NOK 1 - 4 - OK 2 - 3 - OK 3 - 7 - NOK 4 - 4 - OK ... 24 - 8 - NOK É isso\u0026hellip; Tentei focar aqui em dicas que não são comuns nesses tipos de posts, se te ajudou compartilha com a comunidade e se tem alguma sugestão só mandar um PR aqui: https://github.com/fmaced1/fmaced1.github.io\n","permalink":"https://fmaced1.github.io/post/dicas-para-a-certificacao-cka/","summary":"Intro Pretendo compartilhar aqui algumas dicas que não estão na maioria dos posts que vi pela internet quando estava me preparando para a prova.\nEsse post não é um guia de estudos para a certificação CKA, mas se você está procurando por um, recomendo esses:\n https://ravikirans.com/cka-kubernetes-exam-study-guide/ https://dev.to/kodekloud/tips-and-tricks-to-pass-the-cka-and-ckad-exam-c76 https://codeburst.io/the-ckad-browser-terminal-10fab2e8122e https://jimangel.io/post/cka-exam-for-experienced-kubernetes-operators/  Links oficiais sobre a cka:  Sobre a certificação [Link] O que cai na prova? [Link]  Principais tópicos e seus respectivos pesos:    Domain Weight     Troubleshooting 30%   Cluster Architecture, Installation \u0026amp; Configuration 25%   Services \u0026amp; Networking 20%   Workloads \u0026amp; Scheduling 15%   Storage 10%    Não comece pelo kubernetes-the-hard-way O tutorial do @kelseyhightower é excelente, porém acho que não é uma boa idéia investir um tempo considerável, executando um passo a passo que você não irá entender muita coisa do que fez, quando terminar.","title":"Dicas para a certificação CKA"},{"content":"","permalink":"https://fmaced1.github.io/archives/","summary":"archives","title":"Archive"},{"content":"","permalink":"https://fmaced1.github.io/search/","summary":"search","title":"Search"}]